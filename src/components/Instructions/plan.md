# Доклад: Vibe Coding — новый подход к разработке с ИИ

## Слайд 1: Титульный слайд

**Описание слайда:**

- Заголовок: "Vibe Coding: Будущее фронтенд-разработки"
- Подзаголовок: "Как ИИ меняет подход к написанию кода"
- Логотип конференции
- Имя докладчика и дата

**Комментарий для презентации:**
Добро пожаловать! Сегодня мы поговорим о том, как ИИ-инструменты кардинально меняют подход к разработке. Vibe Coding — это не просто использование автодополнения, это новый способ мышления о программировании.

---

## Слайд 2: Проблема современной разработки

**Описание слайда:**

- Заголовок: "Проблемы современной фронтенд-разработки"
- Список проблем:
  - Сложность современных фреймворков
  - Быстрое устаревание технологий
  - Необходимость постоянного обучения
  - Повторяющиеся задачи
- Иллюстрация: график роста сложности

**Комментарий для презентации:**
Фронтенд-разработка становится все сложнее. Новые фреймворки, библиотеки, подходы появляются каждый месяц. Разработчики тратят 60% времени на изучение, а не на создание.

---

## Слайд 3: Что такое Vibe Coding?

**Описание слайда:**

- Заголовок: "Vibe Coding — что это?"
- Определение в центре слайда
- Ключевые принципы:
  - Синергия с ИИ
  - Фокус на архитектуре
  - Быстрая итерация
- Иконки: человек + ИИ = результат

**Комментарий для презентации:**
Vibe Coding — это подход, где разработчик работает в команде с ИИ. Не заменяет, а усиливает. Фокус смещается с написания кода на проектирование и архитектуру.

---

## Слайд 4: Аналогия с армией

**Описание слайда:**

- Заголовок: "ИИ = армия джунов"
- Схема: Полководец (разработчик) → Джуны (ИИ-агенты)
- Текст: "Без лидерства джуны бесполезны"
- Иллюстрация: военная схема командования

**Комментарий для презентации:**
Представьте ИИ как армию джунов. Они могут многое, но без опытного полководца — бесполезны. Ваша задача — быть этим полководцем, принимать решения, планировать стратегию.

---

## Слайд 5: Почему это важно?

**Описание слайда:**

- Заголовок: "Почему Vibe Coding важен?"
- Статистика:
  - 3x быстрее разработка
  - 50% меньше багов
  - 2x больше фокуса на архитектуре
- График: время vs качество

**Комментарий для презентации:**
Исследования показывают: разработчики, использующие ИИ правильно, работают в 3 раза быстрее. Но ключевое слово — "правильно". Это навык, которому нужно учиться.

---

## Слайд 6: Инструменты — обзор

**Описание слайда:**

- Заголовок: "Инструменты Vibe Coding"
- Три колонки:
  - VS Code + плагины
  - Cursor
  - Windsurf
- Сравнительная таблица функций

**Комментарий для презентации:**
Сегодня у нас есть три основных подхода. VS Code с плагинами — для начинающих, Cursor — для профессионалов, Windsurf — для команд.

---

## Слайд 7: VS Code + плагины

**Описание слайда:**

- Заголовок: "VS Code + ИИ-плагины"
- Список плагинов:
  - GitHub Copilot
  - Codeium
  - Tabnine
  - Cursor (как плагин)
- Плюсы и минусы

**Комментарий для презентации:**
VS Code остается стандартом. Плагины дают ИИ как "умное автодополнение". Хорошо для начала, но быстро становится ограничивающим фактором.

---

## Слайд 8: Cursor — ИИ-first IDE

**Описание слайда:**

- Заголовок: "Cursor — IDE для Vibe Coding"
- Ключевые особенности:
  - Встроенный чат-агент
  - Понимание всего кодового базы
  - MCP (Memory Controlled Prompts)
  - Agent Mode
- Скриншот интерфейса

**Комментарий для презентации:**
Cursor построен с нуля для работы с ИИ. Это не VS Code с плагином, а принципиально новый подход к IDE. Агент понимает весь проект, а не только текущий файл.

---

## Слайд 9: Windsurf — командный подход

**Описание слайда:**

- Заголовок: "Windsurf — для команд"
- Особенности:
  - Интеграция с workflow
  - Совместная работа
  - Меньше MCP, больше командных фич
- Сравнение с Cursor

**Комментарий для презентации:**
Windsurf фокусируется на командной работе. Меньше возможностей для индивидуальной настройки, но лучше интеграция с процессами команды.

---

## Слайд 10: Сравнение инструментов

**Описание слайда:**

- Таблица сравнения:
  - Функции
  - Производительность
  - Стоимость
  - Сложность настройки
- Рекомендации для разных сценариев

**Комментарий для презентации:**
Выбор зависит от ваших задач. Начинающим — VS Code, профессионалам — Cursor, командам — Windsurf. Но тренд очевиден: будущее за ИИ-first IDE.

---

## Слайд 11: Основы промт-инжиниринга

**Описание слайда:**

- Заголовок: "Промт-инжиниринг — основа Vibe Coding"
- Три подхода:
  - Zero-shot
  - Few-shot
  - Chain of Thought
- Иллюстрация: лестница сложности

**Комментарий для презентации:**
Правильный промпт — половина успеха. Сегодня мы изучим три основных подхода, от простого к сложному.

---

## Слайд 12: Zero-shot prompting

**Описание слайда:**

- Заголовок: "Zero-shot — простой запрос"
- Пример промпта: "Создай React компонент Button"
- Результат: базовый компонент
- Плюсы и минусы

**Пример кода:**

```
Промпт: "Создай React компонент Button"

Результат:
const Button = ({ children, onClick }) => {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
};
```

**Комментарий для презентации:**
Zero-shot — это когда вы просто просите что-то сделать. Быстро, но результат часто поверхностный. Хорошо для простых задач.

---

## Слайд 13: Few-shot prompting

**Описание слайда:**

- Заголовок: "Few-shot — показываем примеры"
- Пример: показываем 2-3 компонента → просим создать новый
- Результат: компонент в том же стиле
- Код примеров на слайде

**Пример кода:**

```
Примеры:

// Input.tsx
const Input = ({ value, onChange, placeholder }) => {
  return (
    <input
      value={value}
      onChange={onChange}
      placeholder={placeholder}
      className="px-3 py-2 border rounded"
    />
  );
};

// Textarea.tsx
const Textarea = ({ value, onChange, placeholder }) => {
  return (
    <textarea
      value={value}
      onChange={onChange}
      placeholder={placeholder}
      className="px-3 py-2 border rounded"
    />
  );
};

Промпт: "Создай Select компонент в том же стиле"

Результат:
const Select = ({ value, onChange, options }) => {
  return (
    <select
      value={value}
      onChange={onChange}
      className="px-3 py-2 border rounded"
    >
      {options.map(option => (
        <option key={option.value} value={option.value}>
          {option.label}
        </option>
      ))}
    </select>
  );
};
```

**Комментарий для презентации:**
Few-shot — показываем несколько примеров, ИИ понимает паттерн. Результат намного лучше, но требует подготовки примеров.

---

## Слайд 14: Chain of Thought

**Описание слайда:**

- Заголовок: "Chain of Thought — пошаговое рассуждение"
- Пример промпта с рассуждениями
- Результат: более качественный код
- Схема: вопрос → рассуждение → ответ

**Пример кода:**

```
Промпт: "Создай хук useApi для работы с API. Сначала подумай:
1. Какие состояния нужны (loading, data, error)
2. Какие функции нужны (fetch, refetch, reset)
3. Как обрабатывать ошибки
4. Как кешировать данные

Затем создай код"

Результат:
const useApi = (url) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetch = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error('Network error');
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);

  const refetch = useCallback(() => {
    fetch();
  }, [fetch]);

  const reset = useCallback(() => {
    setData(null);
    setError(null);
    setLoading(false);
  }, []);

  return { data, loading, error, fetch, refetch, reset };
};
```

**Комментарий для презентации:**
Chain of Thought — просим ИИ рассуждать пошагово. Дольше, но результат намного качественнее. Особенно важно для сложных задач.

---

## Слайд 15: Практика — переход к Cursor

**Описание слайда:**

- Заголовок: "Переходим к практике"
- Схема: теория → практика
- Что будем изучать:
  - Миграция
  - Настройка
  - Приемы работы
  - Ошибки и риски

**Комментарий для презентации:**
Теперь от теории к практике. Покажу, как реально работать с Cursor, какие подводные камни ждут, и как их избежать.

---

## Слайд 16: Миграция с VS Code

**Описание слайда:**

- Заголовок: "Миграция с VS Code"
- Список совместимости:
  - ✅ Расширения
  - ✅ Горячие клавиши
  - ✅ Настройки
  - ✅ Рабочие пространства
- Время миграции: 5 минут

**Комментарий для презентации:**
Хорошие новости: Cursor полностью совместим с VS Code. Все ваши расширения, настройки, горячие клавиши работают. Миграция займет 5 минут.

---

## Слайд 17: Миграция с JetBrains

**Описание слайда:**

- Заголовок: "Миграция с JetBrains"
- Проблемы:
  - Нет аналогов плагинов
  - Другой UX
  - Другие горячие клавиши
- Решения:
  - Постепенная адаптация
  - Настройка горячих клавиш

**Комментарий для презентации:**
С JetBrains сложнее. Нет 100% аналогов плагинов, придется привыкать к другому UX. Но результат того стоит — получаете ИИ-first IDE.

---

## Слайд 18: .cursorrules — настройка агента

**Описание слайда:**

- Заголовок: ".cursorrules — правила для ИИ"
- Пример файла:
  - Стиль кода
  - Архитектурные принципы
  - Что НЕ делать
  - Предпочтения команды
- Иконка: файл .cursorrules

**Пример кода:**

```
# .cursorrules

## Стиль кода
- Используй TypeScript для всех компонентов
- Применяй функциональные компоненты с хуками
- Используй const assertions для типов
- Применяй camelCase для переменных и функций

## Архитектура
- Создавай переиспользуемые компоненты
- Разделяй логику и представление
- Используй кастомные хуки для бизнес-логики
- Применяй Context для глобального состояния

## Что НЕ делать
- НЕ создавай классовые компоненты
- НЕ используй any тип
- НЕ мутируй props напрямую
- НЕ создавай компоненты без TypeScript
- НЕ используй var

## React специфика
- Используй React.FC для типизации компонентов
- Применяй useCallback для оптимизации
- Используй useMemo для тяжелых вычислений
- Применяй React.memo для предотвращения ре-рендеров
```

**Комментарий для презентации:**
.cursorrules — это "конституция" для вашего ИИ-агента. Здесь вы описываете, как он должен работать. Иногда важнее сказать, что НЕ делать.

---

## Слайд 19: Пример .cursorrules

**Описание слайда:**

- Код файла .cursorrules
- Комментарии к каждому правилу
- Объяснение зачем нужно каждое правило

**Пример кода:**

```
# .cursorrules - React/TypeScript проект

## Общие принципы
- Всегда используй TypeScript
- Следуй принципам SOLID
- Пиши чистый, читаемый код
- Добавляй JSDoc комментарии для сложных функций

## React компоненты
- Используй функциональные компоненты
- Применяй React.FC<Props> для типизации
- Разделяй компоненты на логические части
- Используй default export для компонентов

## Хуки
- Создавай кастомные хуки для переиспользуемой логики
- Используй useCallback для функций, передаваемых в дочерние компоненты
- Применяй useMemo для дорогих вычислений
- Используй useEffect с правильными зависимостями

## Стилизация
- Используй CSS модули или styled-components
- Применяй CSS переменные для тем
- Следуй BEM методологии
- Используй responsive design

## Что НЕ делать
- НЕ используй any тип
- НЕ мутируй state напрямую
- НЕ создавай компоненты без типов
- НЕ используй var
- НЕ создавай классовые компоненты
- НЕ забывай про accessibility
```

**Комментарий для презентации:**
Вот пример реального .cursorrules. Видите, как мы указываем стиль кода, архитектурные принципы, и самое важное — что агент НЕ должен делать.

---

## Слайд 20: Управление контекстом — @ команды

**Описание слайда:**

- Заголовок: "@ команды — точное управление контекстом"
- Список команд:
  - @file — конкретный файл
  - @folder — папка
  - @code — выделенный код
  - @docs — документация
- Примеры использования

**Пример кода:**

```
Примеры @ команд:

@file Button.tsx - работа с конкретным файлом
@folder components - работа с папкой компонентов
@code - работа с выделенным кодом
@docs - работа с документацией

Использование:
"@file Button.tsx добавь валидацию для props"
"@folder components создай структуру для формы"
"@code оптимизируй этот компонент"
"@docs найди информацию о React.memo"
```

**Комментарий для презентации:**
@ команды — это способ точно указать агенту, с чем работать. Вместо "помоги с кодом" говорите "@file Button.tsx помоги с этим компонентом".

---

## Слайд 21: @file в действии

**Описание слайда:**

- Демонстрация использования @file
- До: "помоги с компонентом"
- После: "@file Button.tsx добавь валидацию"
- Результат: более точный ответ

**Комментарий для презентации:**
Видите разницу? С @file агент точно знает, с каким файлом работать, и дает более релевантные советы.

---

## Слайд 22: @folder для архитектуры

**Описание слайда:**

- Демонстрация @folder
- Пример: "@folder components создай структуру"
- Результат: понимание всей архитектуры папки
- Схема папки на слайде

**Комментарий для презентации:**
@folder полезен для архитектурных решений. Агент видит всю структуру папки и может предложить правильную организацию.

---

## Слайд 23: MCP — Memory Controlled Prompts

**Описание слайда:**

- Заголовок: "MCP — память агента"
- Объяснение: агент "помнит" контекст
- Примеры:
  - API документация
  - Специфичные фреймворки
  - Бизнес-логика
- Схема: память → понимание → действие

**Комментарий для презентации:**
MCP — это способ "обучить" агента работать с вашим проектом. Он запоминает API, архитектуру, бизнес-логику и использует это знание.

---

## Слайд 24: Полезные MCP плагины

**Описание слайда:**

- Список популярных MCP:
  - @Docs — документация
  - @Web — поиск в интернете
  - @DB — работа с БД
  - @Git — работа с Git
- Описание каждого

**Пример кода:**

```
Популярные MCP серверы:

1. Context7 - Документация React
   - Официальная документация React.dev
   - 618,295 токенов документации
   - 2,378 примеров кода
   - Обновляется каждые 2 дня

2. Postman - API тестирование
   - Управление коллекциями API
   - Тестирование эндпоинтов
   - Управление окружениями

3. Statsig - Feature Flags
   - Управление флагами функций
   - A/B тестирование
   - Аналитика экспериментов

4. GibsonAI - Базы данных
   - Создание БД по описанию
   - Генерация CRUD API
   - ORM модели и схемы

5. Mailtrap - Email отправка
   - Транзакционные письма
   - Управление шаблонами
   - Аналитика доставки

6. Midday - Бизнес управление
   - Учет времени
   - Управление счетами
   - Финансовая аналитика
```

**Комментарий для презентации:**
Есть готовые MCP плагины для частых задач. @Docs дает доступ к документации, @Web — к интернету, @DB — к базам данных.

---

## Слайд 25: Настройка MCP

**Описание слайда:**

- Пошаговая инструкция настройки
- Конфигурационный файл
- Примеры для React проекта
- Тестирование MCP

**Комментарий для презентации:**
Настройка MCP не сложная, но требует понимания. Покажу, как настроить MCP для React проекта.

---

## Слайд 26: Context7 MCP для React

**Описание слайда:**

- Заголовок: "Context7 — официальная документация React в Cursor"
- Особенности Context7:
  - 618,295 токенов документации
  - 2,378 примеров кода
  - Обновления каждые 2 дня
  - Официальная документация React.dev
- Схема подключения и использования

**Пример кода:**

```
Установка Context7 MCP:

1. В Cursor перейти в Settings → MCP
2. Добавить новый сервер:
   - Name: Context7 React
   - Server URL: https://context7.com/reactjs/react.dev
   - API Key: (получить на context7.com)

Использование в Cursor:

Промпт: "Покажи примеры использования useCallback с Context7"

Результат от Context7:
// Из официальной документации React.dev

const Parent = () => {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // ✅ Правильно: useCallback с зависимостями
  const handleClick = useCallback(() => {
    console.log('Button clicked');
  }, []); // Пустой массив - функция не зависит от props/state

  // ✅ Правильно: useCallback с зависимостями
  const handleSubmit = useCallback((e) => {
    e.preventDefault();
    console.log('Form submitted:', name);
  }, [name]); // Зависит от name

  // ❌ Неправильно: useCallback без необходимости
  const handleClickBad = useCallback(() => {
    console.log('Button clicked');
  }, [count]); // count не используется в функции

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <button onClick={handleClick}>
        Click me
      </button>
      <form onSubmit={handleSubmit}>
        <button type="submit">Submit</button>
      </form>
    </div>
  );
};

// Дополнительные примеры из документации:
// - Мемоизация колбэков для дочерних компонентов
// - Оптимизация производительности
// - Избежание лишних ре-рендеров
```

**Комментарий для презентации:**
Context7 — это MCP сервер, который дает доступ к официальной документации React прямо в Cursor. Агент может искать примеры, объяснения и лучшие практики из React.dev.

---

## Слайд 27: Практические примеры Context7

**Описание слайда:**

- Заголовок: "Context7 в действии — реальные примеры"
- Демонстрация поиска по документации
- Примеры запросов и ответов
- Сравнение с обычным поиском

**Пример кода:**

```
Практические примеры использования Context7:

1. Поиск информации о хуках:
Промпт: "Context7: покажи все хуки для работы с состоянием"

Ответ от Context7:
- useState - для локального состояния
- useReducer - для сложного состояния
- useContext - для глобального состояния
- useRef - для мутабельных значений
- useMemo - для мемоизации вычислений
- useCallback - для мемоизации функций

2. Поиск паттернов оптимизации:
Промпт: "Context7: как оптимизировать производительность React компонентов"

Ответ от Context7:
// Из официальной документации
const ExpensiveComponent = React.memo(({ data }) => {
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: heavyComputation(item)
    }));
  }, [data]);

  const handleClick = useCallback((id) => {
    onItemClick(id);
  }, [onItemClick]);

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} data={item} onClick={handleClick} />
      ))}
    </div>
  );
});

3. Поиск лучших практик:
Промпт: "Context7: покажи лучшие практики для useEffect"

Ответ от Context7:
// ✅ Правильное использование useEffect
useEffect(() => {
  const controller = new AbortController();

  const fetchData = async () => {
    try {
      const response = await fetch(url, {
        signal: controller.signal
      });
      const data = await response.json();
      setData(data);
    } catch (error) {
      if (error.name !== 'AbortError') {
        setError(error);
      }
    }
  };

  fetchData();

  return () => {
    controller.abort();
  };
}, [url]); // Правильные зависимости

// ❌ Неправильное использование
useEffect(() => {
  fetchData();
}, []); // Отсутствуют зависимости
```

**Комментарий для презентации:**
Context7 превращает Cursor в мощный инструмент для работы с React. Вместо поиска в интернете, агент получает точную информацию из официальной документации.

---

## Слайд 28: Приемы работы — промпт в файле

**Описание слайда:**

- Заголовок: "Промпт в отдельном файле"
- Пример: task.md с большим промптом
- Агент отмечает прогресс в файле
- Преимущества: версионирование, шаринг

**Пример кода:**

```
# task.md - Создание системы управления пользователями

## Задача
Создать полноценную систему управления пользователями с CRUD операциями, аутентификацией и ролями.

## Требования
- [ ] Создать API endpoints для пользователей
- [ ] Реализовать аутентификацию JWT
- [ ] Добавить систему ролей (admin, user, moderator)
- [ ] Создать React компоненты для UI
- [ ] Настроить Redux для состояния
- [ ] Добавить валидацию форм
- [ ] Создать тесты для всех компонентов
- [ ] Настроить TypeScript
- [ ] Добавить стили с styled-components

## Технические детали
- Backend: Node.js + Express + MongoDB
- Frontend: React + TypeScript + Redux Toolkit
- Стили: styled-components
- Тесты: Jest + React Testing Library

## Прогресс
✅ Создан базовый API с Express
✅ Настроена MongoDB с Mongoose
✅ Реализована JWT аутентификация
✅ Созданы базовые React компоненты
🔄 Настраиваю Redux store
⏳ Добавляю валидацию форм
⏳ Создаю тесты

## Текущая работа
Сейчас работаю над настройкой Redux store. Нужно:
1. Создать userSlice с асинхронными thunks
2. Настроить middleware для API
3. Создать селекторы для компонентов

## Проблемы
- Нужно решить вопрос с типизацией API ответов
- Валидация форм требует дополнительной настройки

## Следующие шаги
1. Завершить Redux настройку
2. Добавить валидацию с react-hook-form
3. Создать тесты для userSlice
```

**Комментарий для презентации:**
Для больших задач создавайте task.md с детальным промптом. Агент будет отмечать прогресс прямо в файле — получается "живой TODO".

---

## Слайд 29: Пример task.md

**Описание слайда:**

- Код файла task.md
- Структура:
  - Описание задачи
  - Требования
  - Ограничения
  - Прогресс
- Комментарии агента

**Комментарий для презентации:**
Вот пример реального task.md. Агент не только выполняет задачу, но и документирует процесс. Очень удобно для сложных проектов.

---

## Слайд 30: Git workspace — параллельные эксперименты

**Описание слайда:**

- Заголовок: "Git workspace — экспериментируйте безопасно"
- Схема: основная ветка → экспериментальные ветки
- Примеры:
  - Разные подходы к решению
  - A/B тестирование кода
  - Сравнение результатов
- Git команды

**Комментарий для презентации:**
Git workspace позволяет экспериментировать безопасно. Создаете ветки с разными подходами, сравниваете результаты, выбираете лучший.

---

## Слайд 31: Практический пример workspace

**Описание слайда:**

- Демонстрация создания workspace
- Две ветки: "approach-a" и "approach-b"
- Разные промпты для одной задачи
- Сравнение результатов

**Комментарий для презентации:**
Покажу, как создать workspace для экспериментов. Одна ветка — один подход, другая — другой. Сравниваем и выбираем лучший.

---

## Слайд 32: Ошибки агентов — обзор

**Описание слайда:**

- Заголовок: "Ошибки, которые совершают агенты"
- Три категории:
  - Небезопасные команды
  - Потеря фокуса
  - Галлюцинации
- Статистика ошибок

**Комментарий для презентации:**
Агенты не идеальны. Они совершают ошибки, и важно знать, какие именно, чтобы их избежать.

---

## Слайд 33: Небезопасные команды

**Описание слайда:**

- Примеры опасных команд:
  - rm -rf /
  - npm install --force
  - git push --force
- Защита: всегда проверять команды
- Настройки безопасности Cursor

**Комментарий для презентации:**
Агент может предложить удалить всю систему. Всегда проверяйте команды перед выполнением. Cursor предупреждает, но не всегда.

---

## Слайд 34: Потеря фокуса

**Описание слайда:**

- Пример: просим исправить баг → агент переписывает весь компонент
- Причины: слишком большая задача
- Решение: дробить на шаги
- Схема: большая задача → маленькие шаги

**Комментарий для презентации:**
Агент может "уйти в сторону". Просили исправить баг, а он переписал весь компонент. Решение — дробить задачи на маленькие шаги.

---

## Слайд 35: Галлюцинации

**Описание слайда:**

- Примеры галлюцинаций:
  - Несуществующие API
  - Выдуманные функции
  - Неправильные пакеты
- Защита: просить ссылки на документацию
- Проверка кода

**Комментарий для презентации:**
Агент может "выдумать" API или функции. Всегда просите ссылки на документацию и проверяйте код руками.

---

## Слайд 36: Пример галлюцинации

**Описание слайда:**

- Код с несуществующей функцией
- Ошибка при выполнении
- Правильный способ
- Как избежать

**Пример кода:**

```
Галлюцинация агента:
const user = await fetchUserById(123);
const profile = await getUserProfile(user.id);
const avatar = await getAvatarUrl(profile.avatarId);

// Агент "выдумал" эти функции:
// - fetchUserById() - не существует
// - getUserProfile() - не существует
// - getAvatarUrl() - не существует

Ошибка при выполнении:
ReferenceError: fetchUserById is not defined

Правильный способ:
const response = await fetch('/api/users/123');
const user = await response.json();

const profileResponse = await fetch(`/api/profiles/${user.id}`);
const profile = await profileResponse.json();

const avatar = profile.avatar || '/default-avatar.png';

Как избежать:
1. Просите ссылки на документацию
2. Проверяйте существование функций
3. Тестируйте код сразу
4. Используйте TypeScript для проверки типов
```

**Комментарий для презентации:**
Вот пример реальной галлюцинации. Агент "выдумал" функцию, которой не существует. Код не работает, приходится исправлять.

---

## Слайд 37: Главная ошибка разработчика

**Описание слайда:**

- Заголовок: "Главная ошибка — слепое доверие"
- Принцип: "Надеяться на лучшее, готовиться к худшему"
- Схема: доверие + проверка = успех
- Примеры проверок

**Комментарий для презентации:**
Главная ошибка — слепо доверять агенту. Принцип: надейтесь на лучшее, но готовьтесь к худшему. Всегда проверяйте результат.

---

## Слайд 38: Риски Vibe Coding

**Описание слайда:**

- Заголовок: "Риски Vibe Coding"
- Три основных риска:
  - Зависимость от ИИ
  - Проблемы безопасности
  - "Черный ящик"
- Схема рисков

**Комментарий для презентации:**
Vibe Coding не только дает преимущества, но и создает риски. Важно их понимать и минимизировать.

---

## Слайд 39: Зависимость от ИИ

**Описание слайда:**

- Проблема: разработчик "разучивается" думать
- Статистика: 70% разработчиков теряют навыки
- Решение: баланс между ИИ и собственным мышлением
- График: навыки vs время

**Комментарий для презентации:**
Исследования показывают: 70% разработчиков теряют навыки при активном использовании ИИ. Нужен баланс.

---

## Слайд 40: Проблемы безопасности

**Описание слайда:**

- Риски:
  - Утечка данных в промптах
  - Уязвимости в сгенерированном коде
  - Небезопасные зависимости
- Защита: код-ревью, сканирование, политики

**Комментарий для презентации:**
ИИ может случайно "слить" данные или создать уязвимости. Нужны строгие политики безопасности и код-ревью.

---

## Слайд 41: "Черный ящик"

**Описание слайда:**

- Проблема: непонятно, как получен результат
- Сложность отладки
  - Проблемы с ревью кода
- Решение: документирование процесса

**Комментарий для презентации:**
Иногда непонятно, как агент пришел к решению. Это усложняет отладку и ревью кода. Нужно документировать процесс.

---

## Слайд 42: Минимизация рисков

**Описание слайда:**

- Стратегии:
  - Регулярное обучение без ИИ
  - Строгий код-ревью
  - Документирование решений
  - Тестирование сгенерированного кода
- Чек-лист безопасности

**Комментарий для презентации:**
Риски можно минимизировать. Регулярно программируйте без ИИ, строго ревьюьте код, документируйте решения.

---

## Слайд 43: Практические примеры — React компонент

**Описание слайда:**

- Задача: создать UserCard компонент
- Промпт с @file
- Результат: готовый компонент
- Объяснение каждого шага

**Пример кода:**

```
Промпт: "@file UserCard.tsx создай компонент карточки пользователя"

Результат:
interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: number) => void;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  return (
    <div className="user-card">
      <div className="user-card__avatar">
        {user.avatar ? (
          <img src={user.avatar} alt={user.name} />
        ) : (
          <div className="user-card__avatar-placeholder">
            {user.name.charAt(0).toUpperCase()}
          </div>
        )}
      </div>
      <div className="user-card__content">
        <h3 className="user-card__name">{user.name}</h3>
        <p className="user-card__email">{user.email}</p>
      </div>
      <div className="user-card__actions">
        {onEdit && (
          <button onClick={() => onEdit(user)}>
            Редактировать
          </button>
        )}
        {onDelete && (
          <button onClick={() => onDelete(user.id)}>
            Удалить
          </button>
        )}
      </div>
    </div>
  );
};

export default UserCard;
```

**Комментарий для презентации:**
Теперь практика. Покажу, как создать React компонент с помощью Cursor. От промпта до готового кода.

---

## Слайд 44: Рефакторинг с ИИ

**Описание слайда:**

- Исходный код: классовый компонент
- Промпт: "переведи на хуки"
- Результат: функциональный компонент
- Сравнение до/после

**Пример кода:**

```
Исходный код (классовый компонент):
class UserProfile extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      user: null,
      loading: true,
      error: null
    };
  }

  componentDidMount() {
    this.fetchUser();
  }

  fetchUser = async () => {
    try {
      const response = await fetch(`/api/users/${this.props.userId}`);
      const user = await response.json();
      this.setState({ user, loading: false });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  }

  render() {
    const { user, loading, error } = this.state;

    if (loading) return <div>Загрузка...</div>;
    if (error) return <div>Ошибка: {error}</div>;

    return <div>{user.name}</div>;
  }
}

Промпт: "Переведи этот компонент на хуки"

Результат:
const UserProfile: React.FC<{ userId: number }> = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const fetchUser = useCallback(async () => {
    try {
      const response = await fetch(`/api/users/${userId}`);
      const userData = await response.json();
      setUser(userData);
      setLoading(false);
    } catch (err) {
      setError(err.message);
      setLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    fetchUser();
  }, [fetchUser]);

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;

  return <div>{user.name}</div>;
};
```

**Комментарий для презентации:**
ИИ отлично справляется с рефакторингом. Покажу, как перевести классовый компонент на хуки.

---

## Слайд 45: Создание хука

**Описание слайда:**

- Задача: создать useApi хук
- Промпт с примерами
- Результат: готовый хук с TypeScript
- Тестирование хука

**Пример кода:**

```
Промпт: "Создай хук useApi для работы с API с TypeScript"

Результат:
interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

interface UseApiReturn<T> extends ApiState<T> {
  fetch: () => Promise<void>;
  refetch: () => Promise<void>;
  reset: () => void;
}

const useApi = <T>(url: string): UseApiReturn<T> => {
  const [state, setState] = useState<ApiState<T>>({
    data: null,
    loading: false,
    error: null,
  });

  const fetch = useCallback(async () => {
    setState(prev => ({ ...prev, loading: true, error: null }));

    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState({
        data: null,
        loading: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }, [url]);

  const refetch = useCallback(() => {
    return fetch();
  }, [fetch]);

  const reset = useCallback(() => {
    setState({ data: null, loading: false, error: null });
  }, []);

  return {
    ...state,
    fetch,
    refetch,
    reset,
  };
};

// Использование:
const UserList = () => {
  const { data: users, loading, error, fetch } = useApi<User[]>('/api/users');

  useEffect(() => {
    fetch();
  }, [fetch]);

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;

  return (
    <ul>
      {users?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};
```

**Комментарий для презентации:**
ИИ хорошо создает кастомные хуки. Покажу, как создать useApi хук для работы с API.

---

## Слайд 46: Настройка TypeScript

**Описание слайда:**

- Промпт: "настрой TypeScript для React проекта"
- Результат: tsconfig.json
- Объяснение настроек
- Дополнительные типы

**Пример кода:**

```
Промпт: "Настрой TypeScript для React проекта с строгими правилами"

Результат - tsconfig.json:
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["DOM", "DOM.Iterable", "ES6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"],
      "@/components/*": ["components/*"],
      "@/hooks/*": ["hooks/*"],
      "@/utils/*": ["utils/*"],
      "@/types/*": ["types/*"]
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "build",
    "dist"
  ]
}

Дополнительные типы - types/global.d.ts:
declare module '*.module.css' {
  const classes: { [key: string]: string };
  export default classes;
}

declare module '*.svg' {
  const content: React.FunctionComponent<React.SVGAttributes<SVGElement>>;
  export default content;
}
```

**Комментарий для презентации:**
ИИ может настроить TypeScript. Покажу, как получить оптимальную конфигурацию для React проекта.

---

## Слайд 47: Создание тестов

**Описание слайда:**

- Компонент для тестирования
- Промпт: "создай тесты с Jest и RTL"
- Результат: полный набор тестов
- Покрытие тестами

**Пример кода:**

```
Промпт: "Создай тесты для UserCard компонента с Jest и React Testing Library"

Результат - UserCard.test.tsx:
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import UserCard from './UserCard';

const mockUser = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  avatar: 'https://example.com/avatar.jpg'
};

const mockUserWithoutAvatar = {
  id: 2,
  name: 'Jane Smith',
  email: 'jane@example.com'
};

describe('UserCard', () => {
  it('renders user information correctly', () => {
    render(<UserCard user={mockUser} />);

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
    expect(screen.getByAltText('John Doe')).toBeInTheDocument();
  });

  it('renders avatar placeholder when no avatar provided', () => {
    render(<UserCard user={mockUserWithoutAvatar} />);

    expect(screen.getByText('J')).toBeInTheDocument();
    expect(screen.queryByAltText('Jane Smith')).not.toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', () => {
    const mockOnEdit = jest.fn();
    render(<UserCard user={mockUser} onEdit={mockOnEdit} />);

    fireEvent.click(screen.getByText('Редактировать'));
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser);
  });

  it('calls onDelete when delete button is clicked', () => {
    const mockOnDelete = jest.fn();
    render(<UserCard user={mockUser} onDelete={mockOnDelete} />);

    fireEvent.click(screen.getByText('Удалить'));
    expect(mockOnDelete).toHaveBeenCalledWith(1);
  });

  it('does not render action buttons when callbacks are not provided', () => {
    render(<UserCard user={mockUser} />);

    expect(screen.queryByText('Редактировать')).not.toBeInTheDocument();
    expect(screen.queryByText('Удалить')).not.toBeInTheDocument();
  });

  it('renders only edit button when onDelete is not provided', () => {
    const mockOnEdit = jest.fn();
    render(<UserCard user={mockUser} onEdit={mockOnEdit} />);

    expect(screen.getByText('Редактировать')).toBeInTheDocument();
    expect(screen.queryByText('Удалить')).not.toBeInTheDocument();
  });
});
```

**Комментарий для презентации:**
ИИ создает качественные тесты. Покажу, как получить полный набор тестов для React компонента.

---

## Слайд 48: Оптимизация производительности

**Описание слайда:**

- Медленный компонент
- Промпт: "оптимизируй производительность"
- Результат: мемоизация, lazy loading
- Метрики до/после

**Пример кода:**

```
Исходный медленный компонент:
const UserList = ({ users, onUserClick }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [filteredUsers, setFilteredUsers] = useState([]);

  useEffect(() => {
    const filtered = users.filter(user =>
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    setFilteredUsers(filtered);
  }, [users, searchTerm]);

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      {filteredUsers.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onClick={() => onUserClick(user.id)}
        />
      ))}
    </div>
  );
};

Промпт: "Оптимизируй производительность этого компонента"

Результат:
const UserList = React.memo(({ users, onUserClick }) => {
  const [searchTerm, setSearchTerm] = useState('');

  const filteredUsers = useMemo(() => {
    return users.filter(user =>
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [users, searchTerm]);

  const handleUserClick = useCallback((userId) => {
    onUserClick(userId);
  }, [onUserClick]);

  const handleSearchChange = useCallback((e) => {
    setSearchTerm(e.target.value);
  }, []);

  return (
    <div>
      <input
        value={searchTerm}
        onChange={handleSearchChange}
      />
      {filteredUsers.map(user => (
        <UserCard
          key={user.id}
          user={user}
          onClick={handleUserClick}
        />
      ))}
    </div>
  );
});

// Дополнительно - ленивая загрузка:
const LazyUserList = lazy(() => import('./UserList'));

const App = () => (
  <Suspense fallback={<div>Загрузка...</div>}>
    <LazyUserList />
  </Suspense>
);
```

**Комментарий для презентации:**
ИИ может оптимизировать производительность. Покажу, как улучшить медленный компонент.

---

## Слайд 49: Работа с состоянием

**Описание слайда:**

- Сложное состояние приложения
- Промпт: "настрой Redux Toolkit"
- Результат: slice, селекторы, thunks
- Архитектура состояния

**Пример кода:**

```
Промпт: "Настрой Redux Toolkit для управления пользователями с асинхронными операциями"

Результат:

// store/userSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
  selectedUser: User | null;
}

const initialState: UserState = {
  users: [],
  loading: false,
  error: null,
  selectedUser: null,
};

// Асинхронные thunks
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

export const createUser = createAsyncThunk(
  'users/createUser',
  async (userData: Omit<User, 'id'>) => {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData),
    });
    return response.json();
  }
);

const userSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    selectUser: (state, action) => {
      state.selectedUser = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch users';
      })
      .addCase(createUser.fulfilled, (state, action) => {
        state.users.push(action.payload);
      });
  },
});

export const { selectUser, clearError } = userSlice.actions;
export default userSlice.reducer;

// store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './userSlice';

export const store = configureStore({
  reducer: {
    users: userReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// hooks/useAppDispatch.ts
import { useDispatch } from 'react-redux';
import type { AppDispatch } from '../store';

export const useAppDispatch = () => useDispatch<AppDispatch>();

// components/UserList.tsx
import { useSelector, useAppDispatch } from '../hooks';
import { fetchUsers, selectUser } from '../store/userSlice';

const UserList = () => {
  const dispatch = useAppDispatch();
  const { users, loading, error } = useSelector((state) => state.users);

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;

  return (
    <div>
      {users.map(user => (
        <div key={user.id} onClick={() => dispatch(selectUser(user))}>
          {user.name}
        </div>
      ))}
    </div>
  );
};
```

**Комментарий для презентации:**
ИИ отлично работает с состоянием. Покажу, как настроить Redux Toolkit для сложного приложения.

---

## Слайд 50: Интеграция с API

**Описание слайда:**

- API эндпоинты
- Промпт: "создай сервис для работы с API"
- Результат: типизированный сервис
- Обработка ошибок

**Пример кода:**

```
Промпт: "Создай типизированный сервис для работы с API пользователей"

Результат:

// services/api.ts
interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
}

interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
  createdAt: string;
  updatedAt: string;
}

interface CreateUserRequest {
  name: string;
  email: string;
  avatar?: string;
}

interface UpdateUserRequest extends Partial<CreateUserRequest> {
  id: number;
}

class ApiService {
  private baseURL: string;
  private token: string | null = null;

  constructor(baseURL: string) {
    this.baseURL = baseURL;
  }

  setToken(token: string) {
    this.token = token;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.baseURL}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      ...(this.token && { Authorization: `Bearer ${this.token}` }),
      ...options.headers,
    };

    try {
      const response = await fetch(url, { ...options, headers });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      throw new Error(`API request failed: ${error.message}`);
    }
  }

  // Users API
  async getUsers(): Promise<ApiResponse<User[]>> {
    return this.request<User[]>('/users');
  }

  async getUser(id: number): Promise<ApiResponse<User>> {
    return this.request<User>(`/users/${id}`);
  }

  async createUser(userData: CreateUserRequest): Promise<ApiResponse<User>> {
    return this.request<User>('/users', {
      method: 'POST',
      body: JSON.stringify(userData),
    });
  }

  async updateUser(userData: UpdateUserRequest): Promise<ApiResponse<User>> {
    const { id, ...data } = userData;
    return this.request<User>(`/users/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async deleteUser(id: number): Promise<ApiResponse<void>> {
    return this.request<void>(`/users/${id}`, {
      method: 'DELETE',
    });
  }
}

// Создание экземпляра сервиса
export const apiService = new ApiService(process.env.REACT_APP_API_URL || 'http://localhost:3001/api');

// Хук для работы с API
export const useApiService = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const execute = async <T>(operation: () => Promise<T>): Promise<T | null> => {
    setLoading(true);
    setError(null);

    try {
      const result = await operation();
      return result;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return null;
    } finally {
      setLoading(false);
    }
  };

  return { loading, error, execute };
};

// Использование в компоненте
const UserManagement = () => {
  const { loading, error, execute } = useApiService();
  const [users, setUsers] = useState<User[]>([]);

  const loadUsers = async () => {
    const result = await execute(() => apiService.getUsers());
    if (result?.success) {
      setUsers(result.data);
    }
  };

  const createUser = async (userData: CreateUserRequest) => {
    const result = await execute(() => apiService.createUser(userData));
    if (result?.success) {
      setUsers(prev => [...prev, result.data]);
    }
  };

  useEffect(() => {
    loadUsers();
  }, []);

  if (loading) return <div>Загрузка...</div>;
  if (error) return <div>Ошибка: {error}</div>;

  return (
    <div>
      {/* UI компоненты */}
    </div>
  );
};
```

**Комментарий для презентации:**
ИИ создает качественные API сервисы. Покажу, как интегрироваться с внешним API.

---

## Слайд 51: Стилизация компонентов

**Описание слайда:**

- Компонент без стилей
- Промпт: "добавь стили с styled-components"
- Результат: красивые стили
- Адаптивность

**Пример кода:**

```
Промпт: "Создай стили для UserCard компонента с styled-components и темой"

Результат:

// styles/theme.ts
export const theme = {
  colors: {
    primary: '#007bff',
    secondary: '#6c757d',
    success: '#28a745',
    danger: '#dc3545',
    warning: '#ffc107',
    info: '#17a2b8',
    light: '#f8f9fa',
    dark: '#343a40',
    white: '#ffffff',
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '3rem',
  },
  borderRadius: {
    sm: '0.25rem',
    md: '0.5rem',
    lg: '1rem',
  },
  shadows: {
    sm: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
    md: '0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23)',
    lg: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)',
  },
};

// components/UserCard/UserCard.styled.ts
import styled from 'styled-components';
import { theme } from '../../styles/theme';

export const CardContainer = styled.div`
  background: ${theme.colors.white};
  border-radius: ${theme.borderRadius.lg};
  box-shadow: ${theme.shadows.md};
  padding: ${theme.spacing.lg};
  margin: ${theme.spacing.md};
  transition: all 0.3s ease;
  border: 1px solid ${theme.colors.light};

  &:hover {
    box-shadow: ${theme.shadows.lg};
    transform: translateY(-2px);
  }
`;

export const AvatarContainer = styled.div`
  width: 60px;
  height: 60px;
  border-radius: 50%;
  overflow: hidden;
  margin-bottom: ${theme.spacing.md};
  display: flex;
  align-items: center;
  justify-content: center;
  background: ${theme.colors.light};
`;

export const AvatarImage = styled.img`
  width: 100%;
  height: 100%;
  object-fit: cover;
`;

export const AvatarPlaceholder = styled.div`
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: ${theme.colors.primary};
  color: ${theme.colors.white};
  font-size: 1.5rem;
  font-weight: bold;
`;

export const ContentContainer = styled.div`
  margin-bottom: ${theme.spacing.md};
`;

export const UserName = styled.h3`
  margin: 0 0 ${theme.spacing.sm} 0;
  color: ${theme.colors.dark};
  font-size: 1.25rem;
  font-weight: 600;
`;

export const UserEmail = styled.p`
  margin: 0;
  color: ${theme.colors.secondary};
  font-size: 0.9rem;
`;

export const ActionsContainer = styled.div`
  display: flex;
  gap: ${theme.spacing.sm};
  justify-content: flex-end;
`;

export const ActionButton = styled.button<{ variant?: 'primary' | 'danger' }>`
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  border: none;
  border-radius: ${theme.borderRadius.sm};
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;

  ${({ variant = 'primary' }) => {
    switch (variant) {
      case 'primary':
        return `
          background: ${theme.colors.primary};
          color: ${theme.colors.white};
          &:hover {
            background: #0056b3;
          }
        `;
      case 'danger':
        return `
          background: ${theme.colors.danger};
          color: ${theme.colors.white};
          &:hover {
            background: #c82333;
          }
        `;
    }
  }}

  &:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }
`;

// components/UserCard/UserCard.tsx
import React from 'react';
import {
  CardContainer,
  AvatarContainer,
  AvatarImage,
  AvatarPlaceholder,
  ContentContainer,
  UserName,
  UserEmail,
  ActionsContainer,
  ActionButton,
} from './UserCard.styled';

interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

interface UserCardProps {
  user: User;
  onEdit?: (user: User) => void;
  onDelete?: (userId: number) => void;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  return (
    <CardContainer>
      <AvatarContainer>
        {user.avatar ? (
          <AvatarImage src={user.avatar} alt={user.name} />
        ) : (
          <AvatarPlaceholder>
            {user.name.charAt(0).toUpperCase()}
          </AvatarPlaceholder>
        )}
      </AvatarContainer>

      <ContentContainer>
        <UserName>{user.name}</UserName>
        <UserEmail>{user.email}</UserEmail>
      </ContentContainer>

      <ActionsContainer>
        {onEdit && (
          <ActionButton onClick={() => onEdit(user)}>
            Редактировать
          </ActionButton>
        )}
        {onDelete && (
          <ActionButton variant="danger" onClick={() => onDelete(user.id)}>
            Удалить
          </ActionButton>
        )}
      </ActionsContainer>
    </CardContainer>
  );
};

export default UserCard;
```

**Комментарий для презентации:**
ИИ может стилизовать компоненты. Покажу, как создать красивые стили с styled-components.

---

## Слайд 52: Документация компонентов

**Описание слайда:**

- Компонент
- Промпт: "создай Storybook stories"
- Результат: полная документация
- Интерактивные примеры

**Пример кода:**

```
Промпт: "Создай Storybook stories для UserCard компонента"

Результат:

// stories/UserCard.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import UserCard from '../components/UserCard/UserCard';

const meta: Meta<typeof UserCard> = {
  title: 'Components/UserCard',
  component: UserCard,
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
  argTypes: {
    onEdit: { action: 'edit clicked' },
    onDelete: { action: 'delete clicked' },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Default: Story = {
  args: {
    user: {
      id: 1,
      name: 'John Doe',
      email: 'john@example.com',
      avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face',
    },
  },
};

export const WithoutAvatar: Story = {
  args: {
    user: {
      id: 2,
      name: 'Jane Smith',
      email: 'jane@example.com',
    },
  },
};

export const WithActions: Story = {
  args: {
    user: {
      id: 3,
      name: 'Bob Johnson',
      email: 'bob@example.com',
      avatar: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=150&h=150&fit=crop&crop=face',
    },
    onEdit: (user) => console.log('Edit user:', user),
    onDelete: (userId) => console.log('Delete user:', userId),
  },
};

export const ReadOnly: Story = {
  args: {
    user: {
      id: 4,
      name: 'Alice Brown',
      email: 'alice@example.com',
      avatar: 'https://images.unsplash.com/photo-1494790108755-2616b612b786?w=150&h=150&fit=crop&crop=face',
    },
    // Нет onEdit и onDelete - только просмотр
  },
};

export const LongName: Story = {
  args: {
    user: {
      id: 5,
      name: 'Christopher Alexander Johnson-Williams',
      email: 'christopher.alexander.johnson.williams@verylongdomainname.com',
      avatar: 'https://images.unsplash.com/photo-1500648767791-00dcc994a43e?w=150&h=150&fit=crop&crop=face',
    },
    onEdit: (user) => console.log('Edit user:', user),
    onDelete: (userId) => console.log('Delete user:', userId),
  },
};

export const AllVariants: Story = {
  render: () => (
    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1rem' }}>
      <UserCard
        user={{
          id: 1,
          name: 'John Doe',
          email: 'john@example.com',
          avatar: 'https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=150&h=150&fit=crop&crop=face',
        }}
        onEdit={(user) => console.log('Edit user:', user)}
        onDelete={(userId) => console.log('Delete user:', userId)}
      />
      <UserCard
        user={{
          id: 2,
          name: 'Jane Smith',
          email: 'jane@example.com',
        }}
        onEdit={(user) => console.log('Edit user:', user)}
        onDelete={(userId) => console.log('Delete user:', userId)}
      />
      <UserCard
        user={{
          id: 3,
          name: 'Bob Johnson',
          email: 'bob@example.com',
        }}
      />
    </div>
  ),
};

// .storybook/main.ts
import type { StorybookConfig } from '@storybook/react-vite';

const config: StorybookConfig = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx|mdx)'],
  addons: [
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@storybook/addon-a11y',
  ],
  framework: {
    name: '@storybook/react-vite',
    options: {},
  },
  docs: {
    autodocs: 'tag',
  },
};

export default config;
```

**Комментарий для презентации:**
ИИ создает документацию. Покажу, как создать Storybook stories для компонента.

---

## Слайд 53: Заключение

**Описание слайда:**

- Заголовок: "Vibe Coding — это будущее"
- Ключевые выводы:
  - ИИ — инструмент, не замена
  - Нужно учиться работать с ИИ
  - Баланс между автоматизацией и навыками
- Призыв к действию

**Комментарий для презентации:**
Vibe Coding — это не просто тренд, это будущее разработки. Но помните: ИИ — это инструмент, а не замена. Учитесь работать с ним правильно.

---

## Слайд 54: Главная мысль

**Описание слайда:**

- Цитата: "Работа с ИИ — отдельный навык"
- Подзаголовок: "Инвестируйте в развитие, но не забывайте о собственных навыках"
- Схема: ИИ умнеет → разработчик должен умнеть быстрее
- Контакты

**Комментарий для презентации:**
Главная мысль: работа с ИИ — это отдельный навык, которому нужно учиться. Но пока ИИ становится умнее, разработчик, который его использует, должен становиться умнее еще быстрее.

---

## Слайд 55: Спасибо за внимание!

**Описание слайда:**

- Заголовок: "Спасибо за внимание!"
- Вопросы и ответы
- Контакты докладчика
  - Email
  - GitHub
  - LinkedIn
- QR-код с материалами

**Комментарий для презентации:**
Спасибо за внимание! Готов ответить на вопросы. Материалы доклада доступны по QR-коду.

---

## Дополнительные материалы

### Слайд 56: Полезные ресурсы

**Описание слайда:**

- Список ресурсов:
  - Документация Cursor
  - MCP плагины
  - Промпт-инжиниринг гайды
  - Сообщества разработчиков
- Ссылки и QR-коды

**Комментарий для презентации:**
Вот полезные ресурсы для изучения Vibe Coding. Начните с документации Cursor, изучите MCP плагины.

---

### Слайд 57: FAQ

**Описание слайда:**

- Частые вопросы:
  - "Стоит ли переходить с VS Code?"
  - "Как начать с промпт-инжиниринга?"
  - "Какие проекты подходят для Vibe Coding?"
  - "Как не потерять навыки?"
- Ответы на каждый вопрос

**Комментарий для презентации:**
Отвечу на самые частые вопросы. Да, стоит переходить, но постепенно. Начните с простых промптов.

---

### Слайд 58: Следующие шаги

**Описание слайда:**

- План действий:
  1. Установить Cursor
  2. Настроить .cursorrules
  3. Изучить @ команды
  4. Попробовать MCP
  5. Создать первый проект
- Временные рамки

**Комментарий для презентации:**
Вот план действий на следующие недели. Не пытайтесь изучить все сразу — двигайтесь постепенно.

---

### Слайд 59: Контакты и обратная связь

**Описание слайда:**

- Контакты докладчика
- Способы связи
- Обратная связь по докладу
- Предложения по улучшению

**Комментарий для презентации:**
Буду рад обратной связи! Пишите, если есть вопросы или предложения по улучшению доклада.

---

### Слайд 60: Демо-сессия

**Описание слайда:**

- Заголовок: "Живая демонстрация"
- План демо:
  - Создание компонента
  - Рефакторинг
  - Настройка TypeScript
  - Создание тестов
- Время на вопросы

**Комментарий для презентации:**
Теперь живая демонстрация! Покажу реальную работу с Cursor на примере React проекта.

---

### Слайд 61: Вопросы и ответы

**Описание слайда:**

- Заголовок: "Вопросы и ответы"
- Формат: открытый микрофон
- Время: 10-15 минут
- Дополнительные материалы

**Комментарий для презентации:**
Время вопросов! Задавайте любые вопросы по Vibe Coding, Cursor, промпт-инжинирингу.

---

### Слайд 62: До свидания!

**Описание слайда:**

- Заголовок: "До свидания!"
- Благодарность аудитории
- Пожелания успехов
- Контакты для связи

**Комментарий для презентации:**
Спасибо за внимание! Удачи в освоении Vibe Coding. До встречи на следующих конференциях!
